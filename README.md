# Baby Compiler

It's a baby compiler.

## Overview

Source Code
-> Parser (using Lean `declare_syntax_cat` and `Lean.Parser`)
-> AST
-> Type Checker
-> Alpha Renamer (using Lean `FVarId`)
-> LCNF Converter (AST to LCNF)
-> Optimizer (Constant Folding, DCE)
-> LLVM IR Generator
-> LLVM IR

## Syntax

-   **Types:** `Int64`.
-   **Expressions:**
    -   Integer literals (e.g., `123`).
    -   Variables (e.g., `x`).
    -   Addition: `expr1 + expr2`.
    -   Parenthesized expressions: `(expr)`.
-   **Function Definitions:**
    ```lean
    def function_name (param1 : Int64) (param2 : Int64) : Int64 := body_expression
    ```
    -   Parameters and return type are `Int64`.
    -   Body is a single expression.

**Example Function:**
```lean
def my_add (a : Int64) (b : Int64) : Int64 := (a + b) + (a + 3)
```

If successful, this will compile to LLVM IR similar to:
```llvm
define i64 @my_add(i64 %param0, i64 %param1) {
entry:
  %temp0 = add i64 %param1, 5
  %temp1 = add i64 %param0, %temp0
  ret i64 %temp1
}
```
(Note: The raw compiler output uses hash-based names for SSA variables, e.g., `%{12345}`. The example above shows the structurally equivalent form after normalization by the test suite, which ensures consistent comparisons.)
A success message will be printed to the console:
```
Compiling file: my_func.lang...
Successfully compiled my_func.lang and wrote LLVM IR to my_func.ll
```

## Building the Compiler

To build the compiler, run:
```bash
lake build
```
This *should* create an executable compiler `./.lake/build/bin/compiler` (but it's Lake so... you never know.).

To use it run:
```bash
./.lake/build/bin/compiler <input_file.lang> <output_file.ll>
```

*   `<input_file.lang>`: Path the source file.
*   `<output_file.ll>`: Path where the generated LLVM IR will be saved.

Note: The compiler executable might need to be run from the project root directory for it to correctly locate dynamically linked library components if not installed system-wide. (More broadly, if Lake is being mean to you, empty sympathy is the only thing I can offer.)

## Project Structure

*   `README.md`: <- You are here.
*   `lakefile.lean`: Lake build system configuration.
*   `lean-toolchain`: Lean version specification.
*   `Main.lean`: Command-line entry point for the compiler.
*   `Lang/`: Core compiler logic and utilities:
    *   `AST.lean`: Abstract Syntax Tree definitions.
    *   `Syntax.lean`: Text to `Lean.Syntax` conversion.
    *   `Parser.lean`: `Lean.Syntax` to AST conversion.
    *   `Checker.lean`: Type checking.
    *   `AlphaRename.lean`: Variable name resolution.
    *   `LCNF.lean`: Low-Level Compiler Normal Form (IR) definitions.
    *   `Lower.lean`: AST to LCNF conversion.
    *   `Monad.lean`: `LangM`, `LangState`, `LangError` definitions.
    *   `Prim.lean`: Primitive operation definitions (`PrimInfo`).
    *   `Optimize.lean`: Optimization passes
    *   `Codegen.lean`: LCNF to LLVM IR generation.
    *   `Driver.lean`: Core compilation pipeline logic.
    *   `Util.lean`: Enviornment setup.
    *   `Test.lean`: Tests on the sources in `examples`.
    *   `Eval.lean`: A direct evaluator/interpreter for the AST (whose purpose shall remain mysterious for now.)
*   `examples/`: Example programs and expected outputs:
    *   `Sources/`: `.lang` source files.
    *   `ExpectedLLVM/`: `.ll` files with expected LLVM IR.
*   `.gitignore`: Git ignore file for Lean projects.
*   `lake-manifest.json`: Dependency version tracking.

## Examples


1. **Basic Addition Function:**
   ```bash
   # Create a source file
   echo "def add (x : Int64) (y : Int64) : Int64 := x + y" > add.lang
   
   # Compile
   ./.lake/build/bin/compiler add.lang add.ll
   
   # View the generated LLVM IR
   cat add.ll
   ```

   Expected output in `add.ll`:
   ```llvm
   define i64 @add(i64 %{hash0}, i64 %{hash1})
   {
     %{hash2} = add i64 %{hash0}, %{hash1}
     ret i64 %{hash2}
   }
   ```
   The placeholder hashes are the internal names for SSA variables generated by the compiler e.g. %{12345}.

There are also error messages:

```bash
# Syntax error example (using = instead of :=)
echo "def bad (x : Int64) : Int64 = x + 1" > bad.lang
./.lake/build/bin/compiler bad.lang bad.ll
# Output: Syntax Error: <input>:1:28: expected ':=' 

# Undefined variable example (caught by checker)
echo "def use_undef (p : Int64) : Int64 := p + zzz" > use_undef.lang
./.lake/build/bin/compiler use_undef.lang use_undef.ll
# Output: Name Error: Undefined variable 'zzz'

# Duplicate parameter example
echo "def sum (x : Int64) (x : Int64) : Int64 := x + 1" > sum.lang
./.lake/build/bin/compiler sum.lang sum.ll
# Output: Name Error: Duplicate parameter name 'x' in function 'sum'.
```


### Running Tests

The test compiles `.lang` files from `examples/Sources` and compares (upto renaming) the generated LLVM IR against expected `.ll` files in `examples/ExpectedLLVM`.

To run the test:
```bash
lake test
```
You should see output similar to:
```
Running test: test_dce_after_fold
  PASS: test_dce_after_fold
Running test: test_const_fold
  PASS: test_const_fold
Running test: ex_program_func_add
  PASS: ex_program_func_add
All 3 codegen tests passed!
```