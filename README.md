# Baby Compiler

It's a baby compiler.

## The language

-   **Types:** `Int64`.
-   **Expressions:**
    -   Integer literals (e.g., `123`).
    -   Variables (e.g., `x`).
    -   Addition: `expr1 + expr2`.
    -   Parenthesized expressions: `(expr)`.
-   **Function Definitions:**
    ```lean
    def function_name (param1 : Int64) (param2 : Int64) : Int64 := body_expression
    ```
    -   Parameters and return type are `Int64`.
    -   Body is a single expression.

## Using it

To build the compiler, run:
```bash
lake build
```
This *should* create an executable compiler `./.lake/build/bin/compiler` (but it's Lake so... you never know.).

To compile a source file run:
```bash
./.lake/build/bin/compiler <input_file.lang> <output_file.ll>
```

*   `<input_file.lang>`: Path the source file.
*   `<output_file.ll>`: Path where the generated LLVM IR will be saved.


**Example Function:**

```bash
# 1. Create a source file named 'add.lang'
echo "def add (x : Int64) (y : Int64) : Int64 := x + y" > add.lang

# 2. Compile it using the compiler executable
./.lake/build/bin/compiler add.lang add.ll

# 3. View the generated LLVM IR
cat add.ll
```

If successful, `add.ll` will contain LLVM IR similar to this:
```llvm
define i64 @add(i64 %{hash_x}, i64 %{hash_y}) {
  %{hash_result} = add i64 %{hash_x}, %{hash_y}
  ret i64 %{hash_result}
}
```
The placeholder hashes `hash_...` stand for the internal names of SSA variables generated by the compiler e.g. %{92573}.


Note: The `compiler` executable may not work if run outside of the project root directory because of dynamic linking. (More broadly, if Lake is being mean to you, empty sympathy is the only thing I can offer.)

## Architecture

*   `README.md`: <- You are here.
*   `lakefile.lean`: Lake build system configuration.
*   `lean-toolchain`: Lean version specification.
*   `Main.lean`: Command-line entry point for the compiler.
*   `Lang/`: Core compiler logic and utilities:
    *   `AST.lean`: Abstract Syntax Tree definitions.
    *   `Syntax.lean`: Text to `Lean.Syntax` conversion.
    *   `Parser.lean`: `Lean.Syntax` to AST conversion.
    *   `Checker.lean`: Type checking.
    *   `AlphaRename.lean`: Variable name resolution.
    *   `LCNF.lean`: Low-Level Compiler Normal Form (IR) definitions.
    *   `Lower.lean`: AST to LCNF conversion.
    *   `Monad.lean`: `LangM`, `LangState`, `LangError` definitions.
    *   `Prim.lean`: Primitive operation definitions (`PrimInfo`).
    *   `Optimize.lean`: Optimization passes (currently: Constant Folding, DCE)
    *   `Codegen.lean`: LCNF to LLVM IR generation.
    *   `Driver.lean`: Core compilation pipeline logic.
    *   `Util.lean`: Enviornment setup.
    *   `Test.lean`: Tests on the sources in `examples`.
    *   `Eval.lean`: A direct evaluator/interpreter for the AST (whose purpose shall remain mysterious for now.)
*   `examples/`: Example programs and expected outputs:
    *   `Sources/`: `.lang` source files.
    *   `ExpectedLLVM/`: `.ll` files with expected LLVM IR.
*   `.gitignore`: Git ignore file for Lean projects.
*   `lake-manifest.json`: Dependency version tracking.

## Errors

There are also error messages:

```bash
# Syntax error example (using = instead of :=)
echo "def bad (x : Int64) : Int64 = x + 1" > bad.lang
./.lake/build/bin/compiler bad.lang bad.ll
# Output: Syntax Error: <input>:1:28: expected ':=' 

# Undefined variable example (caught by checker)
echo "def use_undef (p : Int64) : Int64 := p + zzz" > use_undef.lang
./.lake/build/bin/compiler use_undef.lang use_undef.ll
# Output: Name Error: Undefined variable 'zzz'

# Duplicate parameter example
echo "def sum (x : Int64) (x : Int64) : Int64 := x + 1" > sum.lang
./.lake/build/bin/compiler sum.lang sum.ll
# Output: Name Error: Duplicate parameter name 'x' in function 'sum'.
```

## Test

The test compiles `.lang` files from `examples/Sources` and compares (upto renaming) the generated LLVM IR against expected `.ll` files in `examples/ExpectedLLVM`.

To run the test:
```bash
lake test
```
You should see:
```
Running test: test_dce_after_fold
  PASS: test_dce_after_fold
Running test: test_const_fold
  PASS: test_const_fold
Running test: ex_program_func_add
  PASS: ex_program_func_add
All 3 codegen tests passed!
```